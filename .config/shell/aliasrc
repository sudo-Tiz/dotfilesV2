#!/bin/zsh

# Use neovim for vim if present.
[ -x "$(command -v nvim)" ] && alias vim="nvim" vimdiff="nvim -d"

# Use $XINITRC variable if file exists.
[ -f "$XINITRC" ] && alias startx="startx $XINITRC"

[ -f "$MBSYNCRC" ] && alias mbsync="mbsync -c $MBSYNCRC"

# sudo not required for some system commands
for command in mount umount updatedb su shutdown poweroff reboot isw; do
  alias $command="sudo $command"
done
unset command

se() {
  cd ~/.local/bin
  $EDITOR $(fzf)
}

# Verbosity and settings that you pretty much just always are going to want.
alias \
  cp="cp -a" \
  mv="mv -i" \
  rm="rm -rf" \
  bc="bc -ql" \
  mkd="mkdir -pv" \
  yt="yt-dlp --embed-metadata -i" \
  yta="yt -x -f bestaudio/best" \
  ffmpeg="ffmpeg -hide_banner"

# Colorize commands when possible.
alias \
  ls="ls -hN --color=auto --group-directories-first" \
  grep="grep --color=auto" \
  diff="diff --color=auto" \
  cat="bat --paging=never -pp" \
  bless="bat -p --pager 'less -RF'" \
  ip="ip -color=auto"

# LS
alias \
  l="eza -F" \
  ll="eza -lF" \
  la="eza -aF" \
  lla="eza -laF" \
  lt="eza -TaF" \
  llt="eza -Tal" \

# CD
alias \
  ...="cd ../.." \
  ....="cd ../../.." \
  .....="cd ../../../.."

# These common commands are just too long! Abbreviate them.
alias \
  ka="killall" \
  trem="transmission-remote" \
  YT="youtube-viewer" \
  sdn="shutdown -h now" \
  v="$EDITOR" \
  sv="sudo nvim" \
  p="pacman" \
  sp="sudo pacman" \
  paru="yay" \
  z="zathura" \
  sysup='sudo systemctl enable --now' \
  sysdn='sudo systemctl disable --now' \
  ref="shortcuts >/dev/null; source ${XDG_CONFIG_HOME:-$HOME/.config}/shell/shortcutrc ; source ${XDG_CONFIG_HOME:-$HOME/.config}/shell/zshnameddirrc" \
  weath="less -S ${XDG_CACHE_HOME:-$HOME/.cache}/weatherreport" \
  ee='exit' \
  tree='tree -CAhF --dirsfirst' \
  egrep="grep -E" \
  fd="fd -Hi" \
  qute-clear="rm -rf ~/.local/share/qutebrowser/webengine; rm -rf ~/.cache/qutebrowser/webengine/" \
  mdtemp="cd $(mktemp -d)" \
  tsumiki="${XDG_CONFIG_HOME:-$HOME/.config}/tsumiki/init.sh"
old() { mv "$1" "$1.old"; }
bak() { cp "$1" "$1.bak"; }
baktar() { tar -zcvf "${1}_$(date '+%Y-%m-%d_%H-%M').tar.gz" "$1"; }

# DOCKER
[ -x "$(command -v docker)" ] && alias \
  doc='sudo /bin/docker' \
  doco='sudo /bin/docker compose' \
  rmdoc='sudo /bin/docker rm -f $(/bin/docker ps -a -q)'

# GIT
[ -x "$(command -v git)" ] && alias \
  g="git" \
  gd="git diff" \
  gcl='git clone' \
  gull='git pull' \
  gush='git push' \
  gusho='git push -f origin' \
  gash="git stash" \
  gme= "git merge" \
  gmest="git merge stash" \
  gco='git commit -m' \
  ga='git add' \
  gr='git restore' \
  grs='git restore --staged' \
  greset1='git reset --hard HEAD~1' \
  gst='git status' \
  gl='git log' \
  gb='git branch' \
  gch="git checkout" \
  gchb="git checkout -b" \
  gls='l --group-directories-first --color=auto -d $(git ls-tree $(git branch | grep \* | cut -d " " -f2) --name-only)' \
  gll='l --group-directories-first --color=auto -d $(git ls-tree -r $(git branch | grep \* | cut -d " " -f2) --name-only)' &&
  gdi() { git diff --name-only --relative --diff-filter=d | xargs bat --diff; }

# VENV
alias \
  ve='python -m venv .venv' \
  va='source .venv/bin/activate || source .env/bin/activate' \
  veva='python -m venv .venv && source .venv/bin/activate' \
  da='deactivate'

# Copy progress bar
[ -x "$(command -v rsync)" ] && alias \
  cpv='rsync -ah --info=progress2' \
  mvv='rsync -ah --remove-source-files --info=progress2'

# Micro to speaker
[ -x "$(command -v pactl)" ] && alias \
  micloopback='pactl unload-module module-loopback >/dev/null 2>&1 | grep Failed && pactl load-module module-loopback latency_msec=1'

# PDF to JPG (need imagemagick)
[ -x "$(command -v convert)" ] && pdftojpg() {
  [ $# = 1 ] && convert -density 150 "$1" -quality 90 "$(echo $1 | sed s/.pdf/%03d.jpg/g)" || echo ERROR
}

[ -x "$(command -v wofi)" ] && alias \
  dmenu='wofi -d'

# Take a picture
alias campic="ffmpeg -f v4l2 -i /dev/video0 -vframes 1 image.jpg"

# Cheatsheet for linux commands
ch() { curl "http://cheat.sh/$1"; }

# RUN THE COMMAND FROM HISTORY, USING FZF AS SELECTOR, ALTERNATIVE TO <C-R>
hf() {
  cmd=$(history 0 | sort -nr | cut -c 8- | fzf -e --select-1 --no-sort --query "$1")
  # push the command into the history
  print -S $cmd
  eval $cmd
}

# list path to other zsh shell opened
lssh() {
  ps au |
    awk '$11 == "/usr/bin/zsh" || $11 == "/bin/zsh" { print $2 }' |
    xargs pwdx |
    awk '{ print $2 }' |
    sed -n "\|^${2}.*|p" |
    sort -u |
    nl
}
# cd to path of another shell, using fzf as selector
cs() {
  if command -v fzf &>/dev/null; then
    cmd1=$(lssh | fzf --select-1 --query "$1" --height=~50 | cut -f 2)
  else
    echo "Select a shell to change directory to:"
    lssh
    read selection
    cmd1=$(lssh | awk -v sel="$selection" 'NR == sel { print $2 }')
  fi
  cmd="cd $cmd1"
  print -S $cmd
  eval $cmd
}

[ -x "$(command -v xdg-open)" ] && pacweb() {
  if [[ $# = 0 || "$1" =~ '--help|-h' ]]; then
    local underline_color="\e[${color[underline]}m"
    echo "$0 - open the website of an ArchLinux package"
    echo
    echo "Usage:"
    echo "    $bold_color$0$reset_color ${underline_color}target${reset_color}"
    return 1
  fi

  local pkg="$1"
  local infos="$(LANG=C pacman -Si "$pkg")"
  if [[ -z "$infos" ]]; then
    return
  fi
  local repo="$(grep -m 1 '^Repo' <<<"$infos" | grep -oP '[^ ]+$')"
  local arch="$(grep -m 1 '^Arch' <<<"$infos" | grep -oP '[^ ]+$')"
  xdg-open "https://www.archlinux.org/packages/$repo/$arch/$pkg/" &>/dev/null
}

# Fix path with xdg
alias mixxx="mixxx --settings-path ~/.config/mixxx"
